// minMalwareSpread.cpp
// leetcode
//
// Created by  Song Ding on 10/22/18.
// Copyright Â© 2018 Song Ding. All rights reserved.
//
#include "common.h"
using namespace std;

namespace minMalwareSpread {

class Solution {
public:
    /**
     * Use union-find to group all nodes into disconnected clusters.
     * if there is a cluster with just one initial node, then removing this
     * initital node would save whole cluster. However, if there is more
     * than one initial node in a cluster, then the contribution of the initial node
     * is 0.
     *
     * Find an initial node which contributes the most.
     */
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> cluster(n);
        for (int i = 0; i < n; ++i) {
            cluster[i] = i;
        }
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (graph[i][j]) {
                    int pi = find_cluster(cluster, i);
                    int pj = find_cluster(cluster, j);
                    if (pi < pj) {
                        cluster[pj] = pi;
                        find_cluster(cluster, j);
                    } else {
                        cluster[pi] = pj;
                        find_cluster(cluster, i);
                    }
                }
            }
        }
        
        map<int, int> clusterSize;
        for (auto i : cluster) {
            ++clusterSize[i];
        }
        
        map<int, set<int>> initialCluster;
        int in = initial.size();
        for (auto i : initial) {
            initialCluster[cluster[i]].insert(i);
        }
        
        int maxc = 0;
        int res = n;
        for (const auto& ic : initialCluster) {
            if (ic.second.size() == 1 && maxc < clusterSize[ic.first]) {
                res = *ic.second.begin();
                maxc = clusterSize[ic.first];
            } else if (ic.second.size() > 1 && (res > *ic.second.begin())) {
                res = *ic.second.begin();
            }
        }
        return res;
    }

private:
    int find_cluster(vector<int>& cluster, int i) {
        if (cluster[i] != i) {
            cluster[i] = find_cluster(cluster, cluster[i]);
        }
        return cluster[i];
    }
};

}

/*/
int main() {
    // TODO: prepare parameters here
    vector<vector<int>> graph {
        //{1,0,0,0},{0,1,0,0},{0,0,1,1},{0,0,1,1}
        {1,1,0,0,0,0,0,0,0,0},{1,1,0,0,0,0,0,0,0,1},{0,0,1,0,1,0,0,0,0,1},{0,0,0,1,0,0,0,0,0,1},{0,0,1,0,1,0,1,0,0,1},{0,0,0,0,0,1,1,0,0,0},{0,0,0,0,1,1,1,0,0,1},{0,0,0,0,0,0,0,1,1,0},{0,0,0,0,0,0,0,1,1,0},{0,1,1,1,1,0,1,0,0,1}
    };
    vector<int> initial {
        //3,1
        9,0,2
    };

    // TODO: add return type and paramters.
    clock_t tstart = clock();
    auto res = minMalwareSpread::Solution().minMalwareSpread(graph, initial);
    cout << clock() - tstart << endl;
    cout << res << endl;
    return 0;
}
//*/
